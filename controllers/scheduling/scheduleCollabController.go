package scheduling

import (
	"fmt"
	"net/http"
	"root/constant"
	"root/database"
	"root/mail"
	"root/model"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/spf13/viper"
)

// CLEANED
// PREORAL DEFENSE
// SMTP Added
// Handle Create Schedule in collab
func HandleCreateSchedule(c *gin.Context) {
	// Extracting the user ID from the context
	userID := c.MustGet("userID").(int)
	notify := c.Query("notify")

	if userID == 0 {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		return
	}

	collabIDStr := c.Param("collab_id")

	// Converting the string to an int
	collabID, err := strconv.Atoi(collabIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collab ID"})
		return
	}

	// Check if empty request body
	if c.Request.ContentLength == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Empty request body"})
		return
	}

	var scheduleJson constant.NewSchedule
	// Bind the request body to the struct
	if err := c.ShouldBindJSON(&scheduleJson); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if missing required fields
	if scheduleJson.ScheduleTitle == "" ||
		scheduleJson.ScheduleTimeStart.IsZero() ||
		scheduleJson.ScheduleTimeEnd.IsZero() {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing required fields"})
		return
	}

	// Get collab
	var collab model.Collab
	if err := database.Db.Where("collab_id = ?", collabID).First(&collab).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Check overlap
	overlap := checkIfScheduleOverlap(collab, scheduleJson)
	if overlap {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Schedule overlaps! Please select another time"})
		return
	}

	// Start transaction
	tx := database.Db.Begin()
	if tx.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}

	// Create the first schedule
	newSchedule := model.Schedule{
		ScheduleTitle:     scheduleJson.ScheduleTitle,
		ScheduleTimeStart: scheduleJson.ScheduleTimeStart,
		ScheduleTimeEnd:   scheduleJson.ScheduleTimeEnd,
		UserID:            userID,
		RepeatInterval:    scheduleJson.RepeatInterval,
	}

	if err := tx.Create(&newSchedule).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Creating the association between the schedule and the collab
	scheduleCollab := model.ScheduleCollab{
		ScheduleID: newSchedule.ScheduleID,
		CollabID:   collabID,
	}
	if err := tx.Create(&scheduleCollab).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// If repeat_interval is greater than 0, create additional schedules
	if newSchedule.RepeatInterval > 0 {
		// Calculate the end date for repeating schedules
		endDate := newSchedule.ScheduleTimeEnd.AddDate(0, 0, 7*newSchedule.RepeatInterval) // Repeat for 'RepeatInterval' weeks

		// Check if the repeat dates has overlap
		for date := newSchedule.ScheduleTimeStart.AddDate(0, 0, 7); date.Before(endDate); date = date.AddDate(0, 0, 7) {
			overlap := checkIfScheduleOverlap(collab, constant.NewSchedule{
				ScheduleTimeStart: date,
				ScheduleTimeEnd:   date.Add(newSchedule.ScheduleTimeEnd.Sub(newSchedule.ScheduleTimeStart)),
			})
			if overlap {
				tx.Rollback()
				c.JSON(http.StatusBadRequest, gin.H{"error": "Schedule overlaps with the repeat dates! Please select another time"})
				return
			}
		}

		// Set the RepeatGroup of the first schedule to its ID
		newSchedule.RepeatGroup = strconv.Itoa(newSchedule.ScheduleID)
		if err := tx.Save(&newSchedule).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		for date := newSchedule.ScheduleTimeStart.AddDate(0, 0, 7); date.Before(endDate); date = date.AddDate(0, 0, 7) {
			repeatingSchedule := model.Schedule{
				ScheduleTitle:     newSchedule.ScheduleTitle,
				ScheduleTimeStart: date,
				ScheduleTimeEnd:   date.Add(newSchedule.ScheduleTimeEnd.Sub(newSchedule.ScheduleTimeStart)),
				UserID:            newSchedule.UserID,
				RepeatInterval:    newSchedule.RepeatInterval,
				RepeatGroup:       newSchedule.RepeatGroup, // Set the RepeatGroup to the ID of the first schedule
			}

			if err := tx.Create(&repeatingSchedule).Error; err != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
				return
			}

			repeatingScheduleCollab := model.ScheduleCollab{
				ScheduleID: repeatingSchedule.ScheduleID, // Use the schedule_id generated by the database
				CollabID:   collabID,
			}
			if err := tx.Create(&repeatingScheduleCollab).Error; err != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
				return
			}
		}
	}

	// SMTP
	createScheduleSMTP := viper.GetBool("mailsmtp.toggle.userpanel.add_schedule")
	if createScheduleSMTP && notify == "yes" {
		var collab model.Collab
		tx.Where("collab_id = ?", collabID).First(&collab)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab"})
		}

		// Get collab member and owner ids
		var members []constant.SimpleUser
		tx.Table("collab_member").
			Select("scholarize_user.user_id, scholarize_user.user_name, scholarize_user.user_email, scholarize_user.user_profile_img").
			Joins("join scholarize_user on scholarize_user.user_id = collab_member.user_id").
			Where("collab_member.collab_id = ? and collab_member.joined = ?", collab.CollabID, true).
			Where("collab_member.user_id != ?", userID).
			Scan(&members)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab members"})
		}

		// Get owner info
		if collab.OwnerID != userID {
			var owner constant.SimpleUser
			tx.Table("scholarize_user").
				Select("user_id, user_name, user_email, user_profile_img").
				Where("user_id = ?", collab.OwnerID).
				Scan(&owner)
			if tx.Error != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab owner"})
			}
			members = append(members, owner)
		}

		// Get user info
		var user model.ScholarizeUser
		if err := tx.Table("scholarize_user").
			Where("user_id = ?", userID).
			First(&user).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve user info"})
			return
		}

		// Send email to all members
		for _, member := range members {
			if member.UserEmail == "" {
				continue
			}

			// Send email
			emailBody := mail.EmailTemplateData{
				PreviewHeader: "Schedule Created for " + collab.CollabName + " by " + user.UserName,
				EmailPurpose:  "Schedule title '" + newSchedule.ScheduleTitle + "' is set for " + newSchedule.ScheduleTimeStart.Format("15:04:05") + " to " + newSchedule.ScheduleTimeEnd.Format("15:04:05 2006-01-02") + " in collaboration group " + collab.CollabName + " by " + user.UserName,
				ActionURL:     viper.GetString("client.userpanel") + "/dashboard/schedule",
				Action:        "View schedule",
				EmailEnding:   "If you believe this is a mistake, please ignore this message.",
			}

			// Customize the email template
			emailBodyData, err := mail.CustomizeHTML(emailBody)
			if err != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Send email to user
			errSending := mail.SendEmail(member.UserEmail, "Scholarize - A new schedule has been created!", emailBodyData)
			if errSending != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Log
			fmt.Printf("Email sent to %s in collab %s\n", member.UserEmail, collab.CollabName)
		}
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Returning a success response
	c.JSON(http.StatusOK, gin.H{
		"message":  "Schedule created successfully for the collab" + collabIDStr,
		"schedule": newSchedule,
	})
}

// CLEANED
// Handle Get all schedules in collab for a specific user ID
func HandleGetAllSchedulesInCollab(c *gin.Context) {
	collabIDStr := c.Param("collab_id")

	// Converting the string to an int
	collabID, err := strconv.Atoi(collabIDStr)
	if err != nil {
		fmt.Println(collabIDStr, err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collab ID"})
		return
	}

	// Extracting the user ID from the context
	userID := c.MustGet("userID").(int)

	if userID == 0 {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		return
	}

	// Query the database for all schedules associated with the collab ID and user ID
	var scheduleCollabs []model.ScheduleCollab
	if err := database.Db.
		Where("schedulecollab.collab_id = ? AND schedule.user_id = ?", collabID, userID).
		Joins("JOIN schedule ON schedulecollab.schedule_id = schedule.schedule_id").
		Find(&scheduleCollabs).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Load data to schedule for each collab schedule
	var schedules []constant.ScheduleDetail
	for _, scheduleCollab := range scheduleCollabs {
		var schedule model.Schedule
		if err := database.Db.Where("schedule_id = ?", scheduleCollab.ScheduleID).First(&schedule).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		var user model.ScholarizeUser
		if err := database.Db.Where("user_id = ?", schedule.UserID).First(&user).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		schedules = append(schedules, constant.ScheduleDetail{
			ScheduleID:        schedule.ScheduleID,
			ScheduleTitle:     schedule.ScheduleTitle,
			ScheduleTimeStart: schedule.ScheduleTimeStart,
			ScheduleTimeEnd:   schedule.ScheduleTimeEnd,
			RepeatInterval:    schedule.RepeatInterval,
			RepeatGroup:       schedule.RepeatGroup,
			UserID:            schedule.UserID,
			UserName:          user.UserName,
		})
	}

	// Get collab
	var collab model.Collab
	if err := database.Db.Where("collab_id = ?", collabID).First(&collab).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Returning the schedules as a response
	c.JSON(http.StatusOK, gin.H{
		"schedules": schedules,
		"collab":    collab,
	})
}

// CLEANED
// SMTP ADDED
// Handle Update Schedule in collab by specific schedule ID
func HandleUpdateSchedule(c *gin.Context) {
	collabIDStr := c.Param("collab_id")
	scheduleIDStr := c.Query("schedule_id")
	notify := c.Query("notify")

	// Check if no collab id or schedule ID
	if collabIDStr == "" || scheduleIDStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Collab ID and schedule ID are required"})
		return
	}

	// Converting the string to an int
	collabID, err := strconv.Atoi(collabIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collab ID"})
		return
	}

	// Convert scheduleID to int
	scheduleID, err := strconv.Atoi(scheduleIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid schedule ID"})
		return
	}

	// Bind the updated schedule data from the request body
	var updatedSchedule constant.UpdateSchedule
	if err := c.ShouldBindJSON(&updatedSchedule); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if the required fields are missing
	if updatedSchedule.ScheduleTitle == "" ||
		updatedSchedule.ScheduleTimeStart.IsZero() ||
		updatedSchedule.ScheduleTimeEnd.IsZero() {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Missing required fields",
		})
		return
	}

	// Start a transaction
	tx := database.Db.Begin()
	if tx.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}

	// Get the existing schedule from the database
	var existingSchedule model.Schedule
	if err := tx.Where("schedule_id = ?", scheduleID).First(&existingSchedule).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"error": "Schedule not found"})
		return
	}

	// Get the associated ScheduleCollab for the existing schedule
	var scheduleCollab model.ScheduleCollab
	if err := tx.Where("schedule_id = ? AND collab_id = ?", existingSchedule.ScheduleID, collabID).First(&scheduleCollab).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"error": "ScheduleCollab not found"})
		return
	}

	// Get user ID from the context
	userID := c.MustGet("userID").(int)
	if userID == 0 {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		return
	}

	// Check if the user is authorized to update the schedule
	if existingSchedule.UserID != userID {
		tx.Rollback()
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized to update the schedule"})
		return
	}

	// Update the schedule in the database
	if err := tx.Model(&existingSchedule).Updates(updatedSchedule).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// SMTP
	updateScheduleSMTP := viper.GetBool("mailsmtp.toggle.userpanel.update_schedule")
	if updateScheduleSMTP && notify == "yes" {
		var collab model.Collab
		tx.Where("collab_id = ?", collabID).First(&collab)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab"})
		}

		// Get collab member and owner ids
		var members []constant.SimpleUser
		tx.Table("collab_member").
			Select("scholarize_user.user_id, scholarize_user.user_name, scholarize_user.user_email, scholarize_user.user_profile_img").
			Joins("join scholarize_user on scholarize_user.user_id = collab_member.user_id").
			Where("collab_member.collab_id = ? and collab_member.joined = ?", collab.CollabID, true).
			Where("collab_member.user_id != ?", userID).
			Scan(&members)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab members"})
		}

		// Get owner info
		if collab.OwnerID != userID {
			var owner constant.SimpleUser
			tx.Table("scholarize_user").
				Select("user_id, user_name, user_email, user_profile_img").
				Where("user_id = ?", collab.OwnerID).
				Scan(&owner)
			if tx.Error != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab owner"})
			}
			members = append(members, owner)
		}

		// Get user info
		var user model.ScholarizeUser
		if err := tx.Table("scholarize_user").
			Where("user_id = ?", userID).
			First(&user).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve user info"})
			return
		}

		// Send email to all members
		for _, member := range members {
			if member.UserEmail == "" {
				continue
			}

			// Send email
			emailBody := mail.EmailTemplateData{
				PreviewHeader: "Schedule Updated for " + collab.CollabName + " by " + user.UserName,
				EmailPurpose:  "Schedule title '" + existingSchedule.ScheduleTitle + "' is updated to " + existingSchedule.ScheduleTimeStart.Format("15:04:05") + "-" + existingSchedule.ScheduleTimeEnd.Format("15:04:05 2006-01-02") + " in collaboration group " + collab.CollabName + " by " + user.UserName,
				ActionURL:     viper.GetString("client.userpanel") + "/dashboard/schedule",
				Action:        "View schedule",
				EmailEnding:   "If you believe this is a mistake, please ignore this message.",
			}

			// Customize the email template
			emailBodyData, err := mail.CustomizeHTML(emailBody)
			if err != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Send email to user
			errSending := mail.SendEmail(member.UserEmail, "Scholarize - Schedule has been updated!", emailBodyData)
			if errSending != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Log
			fmt.Printf("Email sent to %s in collab %s\n", member.UserEmail, collab.CollabName)
		}
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Return a success response
	c.JSON(http.StatusOK, gin.H{
		"message":  "Schedule updated successfully",
		"schedule": existingSchedule,
	})
}

// CLEANED
// SMTP ADDED
// Handle Update All Repeated Schedules in collab by repeat_group following a selected schedule ID
func HandleUpdateRepeatedSchedules(c *gin.Context) {
	collabIDStr := c.Param("collab_id")
	scheduleIDStr := c.Query("schedule_id")
	notify := c.Query("notify")

	// Check if no collab id or schedule ID
	if collabIDStr == "" || scheduleIDStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Collab ID and schedule ID are required"})
		return
	}

	collabID, err := strconv.Atoi(collabIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collab ID"})
		return
	}

	scheduleID, err := strconv.Atoi(scheduleIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid schedule ID"})
		return
	}

	// Bind the updated schedule data from the request body
	var updatedSchedule constant.UpdateRepeatSchedule
	if err := c.ShouldBindJSON(&updatedSchedule); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Check if the required fields are missing
	if updatedSchedule.ScheduleTitle == "" ||
		updatedSchedule.ScheduleTimeStart.IsZero() ||
		updatedSchedule.ScheduleTimeEnd.IsZero() ||
		updatedSchedule.RepeatGroup == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Missing required fields",
		})
		return
	}

	// Start a transaction
	tx := database.Db.Begin()
	if tx.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}

	// Get user ID from the context
	userID := c.MustGet("userID").(int)
	if userID == 0 {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		return
	}

	// Check if schedule is not repeated
	var existingSchedule model.Schedule
	if err := tx.Where("schedule_id = ?", scheduleID).First(&existingSchedule).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"error": "Schedule not found"})
		return
	}

	// Check if the user is authorized to update the schedule
	if existingSchedule.UserID != userID {
		tx.Rollback()
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized to update the schedule"})
		return
	}

	// Check if the schedule is not repeated
	if existingSchedule.RepeatGroup == "" {
		tx.Rollback()
		c.JSON(http.StatusBadRequest, gin.H{"error": "Schedule is not repeated"})
		return
	}

	// Check if the repeated schedule is part of the same repeat group
	if existingSchedule.RepeatGroup != updatedSchedule.RepeatGroup {
		tx.Rollback()
		c.JSON(http.StatusBadRequest, gin.H{"error": "Repeat group does not match the existing schedule"})
		return
	}

	// Fetch all schedules from the specified ID onwards
	var schedulesToUpdate []model.Schedule
	if err := tx.Joins("JOIN schedulecollab ON schedulecollab.schedule_id = schedule.schedule_id").
		Where("schedulecollab.collab_id = ? AND schedule.schedule_id >= ? AND schedule.repeat_group = ?", collabID, scheduleID, updatedSchedule.RepeatGroup).
		Order("schedule_time_start ASC").
		Find(&schedulesToUpdate).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Update all repeated schedules in the database
	for i, schedule := range schedulesToUpdate {
		// Calculate the new date and time for the updated schedule
		updatedTimeStart := updatedSchedule.ScheduleTimeStart.AddDate(0, 0, 7*i) // Add 7 days for each repeated schedule
		updatedTimeEnd := updatedSchedule.ScheduleTimeEnd.AddDate(0, 0, 7*i)     // Add 7 days for each repeated schedule

		// Create a new schedule with the updated date and time
		updatedScheduleCopy := updatedSchedule
		updatedScheduleCopy.ScheduleTimeStart = updatedTimeStart
		updatedScheduleCopy.ScheduleTimeEnd = updatedTimeEnd

		if err := tx.Model(&schedule).Updates(updatedScheduleCopy).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
	}

	// SMTP
	updateScheduleSMTP := viper.GetBool("mailsmtp.toggle.userpanel.update_schedule")
	if updateScheduleSMTP && notify == "yes" {
		var collab model.Collab
		tx.Where("collab_id = ?", collabID).First(&collab)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab"})
		}

		// Get collab member and owner ids
		var members []constant.SimpleUser
		tx.Table("collab_member").
			Select("scholarize_user.user_id, scholarize_user.user_name, scholarize_user.user_email, scholarize_user.user_profile_img").
			Joins("join scholarize_user on scholarize_user.user_id = collab_member.user_id").
			Where("collab_member.collab_id = ? and collab_member.joined = ?", collab.CollabID, true).
			Where("collab_member.user_id != ?", userID).
			Scan(&members)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab members"})
		}

		// Get owner info
		if collab.OwnerID != userID {
			var owner constant.SimpleUser
			tx.Table("scholarize_user").
				Select("user_id, user_name, user_email, user_profile_img").
				Where("user_id = ?", collab.OwnerID).
				Scan(&owner)
			if tx.Error != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab owner"})
			}
			members = append(members, owner)
		}

		// Get user info
		var user model.ScholarizeUser
		if err := tx.Table("scholarize_user").
			Where("user_id = ?", userID).
			First(&user).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve user info"})
			return
		}

		// Send email to all members
		for _, member := range members {
			if member.UserEmail == "" {
				continue
			}

			// Send email
			emailBody := mail.EmailTemplateData{
				PreviewHeader: "Schedule Updated for " + collab.CollabName + " by " + user.UserName,
				EmailPurpose:  "Schedule title '" + existingSchedule.ScheduleTitle + "' is updated to " + existingSchedule.ScheduleTimeStart.Format("15:04:05") + "-" + existingSchedule.ScheduleTimeEnd.Format("15:04:05 2006-01-02") + " in collaboration group " + collab.CollabName + " by " + user.UserName,
				ActionURL:     viper.GetString("client.userpanel") + "/dashboard/schedule",
				Action:        "View schedule",
				EmailEnding:   "If you believe this is a mistake, please ignore this message.",
			}

			// Customize the email template
			emailBodyData, err := mail.CustomizeHTML(emailBody)
			if err != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Send email to user
			errSending := mail.SendEmail(member.UserEmail, "Scholarize - Schedule has been updated!", emailBodyData)
			if errSending != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Log
			fmt.Printf("Email sent to %s in collab %s\n", member.UserEmail, collab.CollabName)
		}
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Repeated schedules updated successfully",
		"updated": schedulesToUpdate,
	})
}

// SMTP
// CLEANED
// Handle Delete Schedule in collab by specific schedule ID
func HandleDeleteSchedule(c *gin.Context) {
	collabIDStr := c.Param("collab_id")
	scheduleIDStr := c.Query("schedule_id")
	notify := c.Query("notify")

	// Check if no collab id or schedule ID
	if collabIDStr == "" || scheduleIDStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Collab ID and schedule ID are required"})
		return
	}

	collabID, err := strconv.Atoi(collabIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collab ID"})
		return
	}

	scheduleID, err := strconv.Atoi(scheduleIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid schedule ID"})
		return
	}

	// Start the transaction
	tx := database.Db.Begin()
	if tx.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}

	// Get UserID from the context
	userID := c.MustGet("userID").(int)
	if userID == 0 {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		return
	}

	// Get the schedule data from the database
	var schedule model.Schedule
	if err := tx.Where("schedule_id = ?", scheduleID).First(&schedule).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"error": "Schedule not found"})
		return
	}

	// Check if the user is authorized to delete the schedule
	// If the user is not the owner of the schedule or the owner of the collab, return an unauthorized error
	if schedule.UserID != userID {
		// Check if the user is the owner of the collab
		var collab model.Collab
		if err := tx.Where("collab_id = ?", collabID).First(&collab).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		if collab.OwnerID != userID {
			tx.Rollback()
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized to delete the schedule"})
			return
		}
	}

	// Get the schedulecollab data from the database
	var scheduleCollab model.ScheduleCollab
	if err := tx.Where("collab_id = ? AND schedule_id = ?", collabID, scheduleID).First(&scheduleCollab).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"error": "ScheduleCollab not found"})
		return
	}

	// If found delete the record
	if err := tx.Delete(&scheduleCollab).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Delete from schedule table
	if err := tx.Delete(&schedule).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// SMTP
	deleteScheduleSMTP := viper.GetBool("mailsmtp.toggle.userpanel.delete_schedule")
	if deleteScheduleSMTP && notify == "yes" {
		// Get user id
		userID := c.MustGet("userID").(int)
		if userID == 0 {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		}

		var collab model.Collab
		tx.Where("collab_id = ?", collabID).First(&collab)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab"})
		}

		// Get collab member and owner ids
		var members []constant.SimpleUser
		tx.Table("collab_member").
			Select("scholarize_user.user_id, scholarize_user.user_name, scholarize_user.user_email, scholarize_user.user_profile_img").
			Joins("join scholarize_user on scholarize_user.user_id = collab_member.user_id").
			Where("collab_member.collab_id = ? and collab_member.joined = ?", collab.CollabID, true).
			Where("collab_member.user_id != ?", userID).
			Scan(&members)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab members"})
		}

		// Get owner info
		if collab.OwnerID != userID {
			var owner constant.SimpleUser
			tx.Table("scholarize_user").
				Select("user_id, user_name, user_email, user_profile_img").
				Where("user_id = ?", collab.OwnerID).
				Scan(&owner)
			if tx.Error != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab owner"})
			}
			members = append(members, owner)
		}

		// Get user info
		var user model.ScholarizeUser
		if err := tx.Table("scholarize_user").
			Where("user_id = ?", userID).
			First(&user).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve user info"})
			return
		}

		// Send email to all members
		for _, member := range members {
			if member.UserEmail == "" {
				continue
			}

			// Send email
			emailBody := mail.EmailTemplateData{
				PreviewHeader: "A Schedule Has Been DELETED in " + collab.CollabName + " by " + user.UserName,
				EmailPurpose:  "Schedule title '" + schedule.ScheduleTitle + "' has been deleted by " + user.UserName + " in collaboration group " + collab.CollabName,
				ActionURL:     viper.GetString("client.userpanel") + "/dashboard/schedule",
				Action:        "View schedule",
				EmailEnding:   "If you believe this is a mistake, please ignore this message.",
			}

			// Customize the email template
			emailBodyData, err := mail.CustomizeHTML(emailBody)
			if err != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Send email to user
			errSending := mail.SendEmail(member.UserEmail, "Scholarize - Schedule has been deleted!", emailBodyData)
			if errSending != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Log
			fmt.Printf("Email sent to %s in collab %s\n", member.UserEmail, collab.CollabName)
		}
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// If the deletion is successful, return a success message
	c.JSON(http.StatusOK, gin.H{
		"message":  "Schedule deleted successfully",
		"deleted":  schedule,
		"collabID": collabID,
	})
}

// SMTP
// CLEANED
// Handle Delete All Repeated Schedules in collab by repeat_group following a selected schedule ID
func HandleDeleteRepeatedSchedules(c *gin.Context) {
	collabIDStr := c.Param("collab_id")
	repeatGroup := c.Query("repeat_group")
	scheduleID := c.Query("schedule_id")
	notify := c.Query("notify")

	// Check if the collab ID, repeat group, scheduleID is empty
	if collabIDStr == "" || repeatGroup == "" || scheduleID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Collab ID, repeat group, and schedule ID are required"})
		return
	}

	// Convert the collabID from string to int
	collabID, err := strconv.Atoi(collabIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid collab ID"})
		return
	}

	// Convert the scheduleID from string to int
	startingScheduleID, err := strconv.Atoi(scheduleID)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid schedule ID"})
		return
	}

	// Start the transaction
	tx := database.Db.Begin()
	if tx.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start transaction"})
		return
	}

	// Get user id
	userID := c.MustGet("userID").(int)
	if userID == 0 {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		return
	}

	// Check if the schedule exists
	var schedule model.Schedule
	if err := tx.Where("schedule_id = ?", startingScheduleID).First(&schedule).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"error": "Schedule not found"})
		return
	}

	// Check if the user is authorized to delete the schedule
	if schedule.UserID != userID {
		tx.Rollback()
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized to delete the schedule"})
		return
	}

	// Get the schedulecollab data from the database
	var scheduleCollab model.ScheduleCollab
	if err := tx.Where("collab_id = ? AND schedule_id = ?", collabID, scheduleID).First(&scheduleCollab).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"error": "ScheduleCollab not found"})
		return
	}

	// Get the schedule IDs for the given collab ID and repeat group, starting from the specified schedule ID
	var scheduleIDs []int
	if err := tx.Table("schedulecollab").Joins("JOIN schedule ON schedulecollab.schedule_id = schedule.schedule_id").
		Where("schedulecollab.collab_id = ? AND schedule.repeat_group = ? AND schedule.schedule_id >= ?", collabID, repeatGroup, startingScheduleID).
		Pluck("schedule.schedule_id", &scheduleIDs).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Check if there are any schedules to delete
	if len(scheduleIDs) == 0 {
		tx.Rollback()
		c.JSON(http.StatusNotFound, gin.H{"message": "No schedules found to delete from the given starting schedule ID onward"})
		return
	}

	// Loop through the schedule IDs and delete the schedules
	// Delete the repeated schedules from the schedule table
	if err := tx.Where("schedule_id IN (?)", scheduleIDs).Delete(&model.Schedule{}).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Delete the repeated schedules from the schedulecollab table
	if err := tx.Where("schedule_id IN (?) AND collab_id = ?", scheduleIDs, collabID).Delete(&model.ScheduleCollab{}).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	deleteScheduleSMTP := viper.GetBool("mailsmtp.toggle.userpanel.delete_schedule")
	if deleteScheduleSMTP && notify == "yes" {
		// Get user id
		userID := c.MustGet("userID").(int)
		if userID == 0 {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID not found in context"})
		}

		var collab model.Collab
		tx.Where("collab_id = ?", collabID).First(&collab)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab"})
		}

		// Get collab member and owner ids
		var members []constant.SimpleUser
		tx.Table("collab_member").
			Select("scholarize_user.user_id, scholarize_user.user_name, scholarize_user.user_email, scholarize_user.user_profile_img").
			Joins("join scholarize_user on scholarize_user.user_id = collab_member.user_id").
			Where("collab_member.collab_id = ? and collab_member.joined = ?", collab.CollabID, true).
			Where("collab_member.user_id != ?", userID).
			Scan(&members)
		if tx.Error != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab members"})
		}

		// Get owner info
		if collab.OwnerID != userID {
			var owner constant.SimpleUser
			tx.Table("scholarize_user").
				Select("user_id, user_name, user_email, user_profile_img").
				Where("user_id = ?", collab.OwnerID).
				Scan(&owner)
			if tx.Error != nil {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get collab owner"})
			}
			members = append(members, owner)
		}

		// Get user info
		var user model.ScholarizeUser
		if err := tx.Table("scholarize_user").
			Where("user_id = ?", userID).
			First(&user).Error; err != nil {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve user info"})
			return
		}

		// Send email to all members
		for _, member := range members {
			if member.UserEmail == "" {
				continue
			}

			// Send email
			emailBody := mail.EmailTemplateData{
				PreviewHeader: "A Schedule Has Been DELETED in " + collab.CollabName + " by " + user.UserName,
				EmailPurpose:  "Schedule title '" + schedule.ScheduleTitle + "' has been deleted by " + user.UserName + " in collaboration group " + collab.CollabName,
				ActionURL:     viper.GetString("client.userpanel") + "/dashboard/schedule",
				Action:        "View schedule",
				EmailEnding:   "If you believe this is a mistake, please ignore this message.",
			}

			// Customize the email template
			emailBodyData, err := mail.CustomizeHTML(emailBody)
			if err != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Send email to user
			errSending := mail.SendEmail(member.UserEmail, "Scholarize - Schedule has been deleted!", emailBodyData)
			if errSending != nil {
				fmt.Print("Error customizing email template: ", err)
				continue
			}

			// Log
			fmt.Printf("Email sent to %s in collab %s\n", member.UserEmail, collab.CollabName)
		}
	}

	// Commit the transaction
	if err := tx.Commit().Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Repeated schedules and their collaborations deleted successfully",
		"deleted": scheduleIDs,
	})
}

// check if schedule is overlapping
func checkIfScheduleOverlap(collab model.Collab, newSchedules constant.NewSchedule) bool {
	// Check if the owner schedule has overlapping time
	collabOftheOwner := GetCollabOfUserOwner(collab.OwnerID)

	schedules, err := GetCollabSchedulesOfOwnerToday(collabOftheOwner, newSchedules.ScheduleTimeStart, newSchedules.ScheduleTimeEnd)
	if err != nil {
		fmt.Printf("Error getting schedules of the owner: %v\n", err)
		return true
	}

	if CheckOwnerOverlappingTime(schedules, newSchedules.ScheduleTimeStart, newSchedules.ScheduleTimeEnd) {
		return true
	}
	return false
}
